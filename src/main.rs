use clap::Parser;
use ignore::{WalkBuilder, overrides::OverrideBuilder};
use std::collections::HashSet;
use std::fs;
use std::io::Write;
use std::path::{Path, PathBuf};

#[derive(Parser)]
#[command(name = "repo-context")]
#[command(about = "Generate repository context for AI consumption", long_about = None)]
struct Cli {
    /// Output file path
    #[arg(short, long, default_value = "context.md")]
    output: PathBuf,

    /// Additional patterns to exclude (comma-separated)
    #[arg(short, long)]
    exclude: Option<String>,

    /// Force include patterns (comma-separated) - overrides .gitignore and .repoignore
    #[arg(short, long)]
    include: Option<String>,

    /// Show file tree only (no content)
    #[arg(short, long)]
    tree_only: bool,
}

fn load_repoignore() -> std::io::Result<Vec<String>> {
    let repoignore_path = Path::new(".repoignore");
    
    if !repoignore_path.exists() {
        return Ok(Vec::new());
    }
    
    let content = fs::read_to_string(repoignore_path)?;
    let patterns: Vec<String> = content
        .lines()
        .map(|line| line.trim())
        .filter(|line| !line.is_empty() && !line.starts_with('#'))
        .map(|line| line.to_string())
        .collect();
    
    Ok(patterns)
}

fn main() -> std::io::Result<()> {
    let cli = Cli::parse();
    
    // Collect all exclusion and inclusion patterns
    let mut exclude_patterns = Vec::new();
    let mut include_patterns = Vec::new();
    
    // 1. Read .repoignore if exists
    match load_repoignore() {
        Ok(patterns) => {
            if !patterns.is_empty() {
                println!("üìã Loaded {} patterns from .repoignore", patterns.len());
                exclude_patterns.extend(patterns);
            }
        }
        Err(e) => {
            eprintln!("‚ö†Ô∏è  Warning: Could not read .repoignore: {}", e);
        }
    }
    
    // 2. Add from -e flag (exclude)
    if let Some(exclude_str) = &cli.exclude {
        let cli_patterns: Vec<String> = exclude_str
            .split(',')
            .map(|s| s.trim().to_string())
            .filter(|s| !s.is_empty())
            .collect();
        
        if !cli_patterns.is_empty() {
            println!("‚ûñ Added {} exclusion patterns from --exclude flag", cli_patterns.len());
            exclude_patterns.extend(cli_patterns);
        }
    }
    
    // 3. Add from -i flag (include - force override)
    if let Some(include_str) = &cli.include {
        let cli_patterns: Vec<String> = include_str
            .split(',')
            .map(|s| s.trim().to_string())
            .filter(|s| !s.is_empty())
            .collect();
        
        if !cli_patterns.is_empty() {
            println!("‚ûï Added {} force-include patterns from --include flag", cli_patterns.len());
            include_patterns.extend(cli_patterns);
        }
    }
    
    // Create override builder for exclusions
    let mut override_builder = OverrideBuilder::new(".");
    
    // Add exclusions (with ! prefix = exclude)
    for pattern in &exclude_patterns {
        override_builder.add(&format!("!{}", pattern))
            .map_err(|e| std::io::Error::new(std::io::ErrorKind::InvalidInput, e))?;
    }
    
    let overrides = override_builder.build()
        .map_err(|e| std::io::Error::new(std::io::ErrorKind::InvalidInput, e))?;
    
    let mut output = String::new();
    
    // Header
    output.push_str("# Repository Context\n\n");
    output.push_str("Generated by repo-context\n\n");
    
    // Show exclusions and inclusions
    if !exclude_patterns.is_empty() {
        output.push_str("## Additional Exclusions\n\n");
        for pattern in &exclude_patterns {
            output.push_str(&format!("- ‚ùå `{}`\n", pattern));
        }
        output.push_str("\n");
    }

    if !include_patterns.is_empty() {
        output.push_str("## Force Included (Override .gitignore)\n\n");
        for pattern in &include_patterns {
            output.push_str(&format!("- ‚úÖ `{}`\n", pattern));
        }
        output.push_str("\n");
    }
    
    // File tree
    output.push_str("## File Tree\n\n```\n");
    
    let mut files_to_process = Vec::new();
    let mut all_paths = HashSet::new();
    
    // PASS 1: Collect normal files respecting .gitignore
    for result in WalkBuilder::new(".")
        .hidden(false)
        .git_ignore(true)
        .git_exclude(true)
        .overrides(overrides.clone())
        .build() 
    {
        let entry = match result {
            Ok(entry) => entry,
            Err(_) => continue,
        };
        
        let path = entry.path();
        
        // Skip the output file itself
        if path == cli.output.as_path() {
            continue;
        }
        
        // Skip .git directory explicitly
        if path.components().any(|c| c.as_os_str() == ".git") {
            continue;
        }
        
        if entry.file_type().map(|ft| ft.is_file()).unwrap_or(false) {
            all_paths.insert(path.to_path_buf());
        }
    }
    
    // PASS 2: Force include - collect files ignoring .gitignore
    if !include_patterns.is_empty() {
        let mut include_override = OverrideBuilder::new(".");
        
        // Add include patterns
        for pattern in &include_patterns {
            include_override.add(pattern)
                .map_err(|e| std::io::Error::new(std::io::ErrorKind::InvalidInput, e))?;
        }
        
        let include_overrides = include_override.build()
            .map_err(|e| std::io::Error::new(std::io::ErrorKind::InvalidInput, e))?;
        
        // Second pass WITHOUT .gitignore, only with include patterns
        for result in WalkBuilder::new(".")
            .hidden(false)
            .git_ignore(false)  // IMPORTANT: disable .gitignore
            .git_exclude(false)
            .overrides(include_overrides)
            .build() 
        {
            let entry = match result {
                Ok(entry) => entry,
                Err(_) => continue,
            };
            
            let path = entry.path();
            
            if path == cli.output.as_path() {
                continue;
            }
            
            if path.components().any(|c| c.as_os_str() == ".git") {
                continue;
            }
            
            if entry.file_type().map(|ft| ft.is_file()).unwrap_or(false) {
                all_paths.insert(path.to_path_buf());
            }
        }
    }
    
    // Sort for stable output
    let mut sorted_paths: Vec<PathBuf> = all_paths.into_iter().collect();
    sorted_paths.sort();
    
    // Build directory structure from file paths
    let mut directories = HashSet::new();
    for path in &sorted_paths {
        let mut current = path.as_path();
        while let Some(parent) = current.parent() {
            if parent == Path::new(".") {
                break;
            }
            directories.insert(parent.to_path_buf());
            current = parent;
        }
    }

    // Combine directories and files, then sort
    let mut all_entries: Vec<(PathBuf, bool)> = Vec::new(); // (path, is_file)

    for dir in directories {
        all_entries.push((dir, false));
    }

    for file in &sorted_paths {
        all_entries.push((file.clone(), true));
    }

    // Sort by path for proper tree structure
    all_entries.sort_by(|a, b| a.0.cmp(&b.0));

    // Output file tree
    for (path, is_file) in &all_entries {
        let depth = path.components().count() - 1;
        let indent = "  ".repeat(depth);
        
        if *is_file {
            output.push_str(&format!("{}üìÑ {}\n", indent, path.display()));
            if !cli.tree_only {
                files_to_process.push(path.clone());
            }
        } else {
            let dir_name = path.file_name().unwrap_or_default().to_string_lossy();
            output.push_str(&format!("{}üìÅ {}\n", indent, dir_name));
        }
    }
    
    output.push_str("```\n\n");
    
    // File contents
    if !cli.tree_only {
        output.push_str("## File Contents\n\n");
        
        for path in &files_to_process {
            output.push_str(&format!("<file path=\"{}\">\n", path.display()));
            
            match fs::read_to_string(path) {
                Ok(content) => {
                    output.push_str(&content);
                    if !content.ends_with('\n') {
                        output.push('\n');
                    }
                }
                Err(_) => {
                    output.push_str("(binary file or read error)\n");
                }
            }
            
            output.push_str("</file>\n\n");
        }
    }
    
    // Write output
    let mut file = fs::File::create(&cli.output)?;
    file.write_all(output.as_bytes())?;
    
    println!("‚úÖ Context generated: {}", cli.output.display());
    println!("üìä Total size: {} bytes", output.len());
    println!("üìÅ Files processed: {}", files_to_process.len());
    
    Ok(())
}
