use clap::Parser;
use ignore::{WalkBuilder, overrides::OverrideBuilder};
use std::fs;
use std::io::Write;
use std::path::{Path, PathBuf};

#[derive(Parser)]
#[command(name = "repo-context")]
#[command(about = "Generate repository context for AI consumption", long_about = None)]
struct Cli {
    /// Output file path
    #[arg(short, long, default_value = "context.md")]
    output: PathBuf,

    /// Additional patterns to exclude (comma-separated)
    #[arg(short, long)]
    exclude: Option<String>,

    /// Show file tree only (no content)
    #[arg(short, long)]
    tree_only: bool,
}

fn load_repoignore() -> std::io::Result<Vec<String>> {
    let repoignore_path = Path::new(".repoignore");
    
    if !repoignore_path.exists() {
        return Ok(Vec::new());
    }
    
    let content = fs::read_to_string(repoignore_path)?;
    let patterns: Vec<String> = content
        .lines()
        .map(|line| line.trim())
        .filter(|line| !line.is_empty() && !line.starts_with('#'))
        .map(|line| line.to_string())
        .collect();
    
    Ok(patterns)
}

fn main() -> std::io::Result<()> {
    let cli = Cli::parse();
    
    // –°–æ–±–∏—Ä–∞–µ–º –≤—Å–µ –ø–∞—Ç—Ç–µ—Ä–Ω—ã –∏—Å–∫–ª—é—á–µ–Ω–∏–π
    let mut exclude_patterns = Vec::new();
    
    // 1. –ß–∏—Ç–∞–µ–º .repoignore –µ—Å–ª–∏ –µ—Å—Ç—å
    match load_repoignore() {
        Ok(patterns) => {
            if !patterns.is_empty() {
                println!("üìã Loaded {} patterns from .repoignore", patterns.len());
                exclude_patterns.extend(patterns);
            }
        }
        Err(e) => {
            eprintln!("‚ö†Ô∏è  Warning: Could not read .repoignore: {}", e);
        }
    }
    
    // 2. –î–æ–±–∞–≤–ª—è–µ–º –∏–∑ —Ñ–ª–∞–≥–∞ -e
    if let Some(exclude_str) = &cli.exclude {
        let cli_patterns: Vec<String> = exclude_str
            .split(',')
            .map(|s| s.trim().to_string())
            .filter(|s| !s.is_empty())
            .collect();
        
        if !cli_patterns.is_empty() {
            println!("üìã Added {} patterns from --exclude flag", cli_patterns.len());
            exclude_patterns.extend(cli_patterns);
        }
    }
    
    // –°–æ–∑–¥–∞—ë–º override builder –¥–ª—è –∫–∞—Å—Ç–æ–º–Ω—ã—Ö –ø–∞—Ç—Ç–µ—Ä–Ω–æ–≤
    let mut override_builder = OverrideBuilder::new(".");
    
    for pattern in &exclude_patterns {
        override_builder.add(&format!("!{}", pattern))
            .map_err(|e| std::io::Error::new(std::io::ErrorKind::InvalidInput, e))?;
    }
    
    let overrides = override_builder.build()
        .map_err(|e| std::io::Error::new(std::io::ErrorKind::InvalidInput, e))?;
    
    let mut output = String::new();
    
    // Header
    output.push_str("# Repository Context\n\n");
    output.push_str("Generated by repo-context\n\n");
    
    if !exclude_patterns.is_empty() {
        output.push_str("## Exclusions\n\n");
        output.push_str("Additional patterns excluded:\n");
        for pattern in &exclude_patterns {
            output.push_str(&format!("- `{}`\n", pattern));
        }
        output.push_str("\n");
    }
    
    // File tree
    output.push_str("## File Tree\n\n```\n");
    
    let mut files_to_process = Vec::new();
    
    // WalkBuilder —Å –∫–∞—Å—Ç–æ–º–Ω—ã–º–∏ –∏—Å–∫–ª—é—á–µ–Ω–∏—è–º–∏
    for result in WalkBuilder::new(".")
        .hidden(false)
        .git_ignore(true)
        .git_exclude(true)
        .overrides(overrides)
        .build() 
    {
        let entry = match result {
            Ok(entry) => entry,
            Err(_) => continue,
        };
        
        let path = entry.path();
        
        // Skip the output file itself
        if path == cli.output.as_path() {
            continue;
        }
        
        // Skip .git directory explicitly
        if path.components().any(|c| c.as_os_str() == ".git") {
            continue;
        }
        
        // Calculate depth for tree visualization
        let depth = path.components().count() - 1;
        let indent = "  ".repeat(depth);
        
        if entry.file_type().map(|ft| ft.is_file()).unwrap_or(false) {
            output.push_str(&format!("{}üìÑ {}\n", indent, path.display()));
            if !cli.tree_only {
                files_to_process.push(path.to_path_buf());
            }
        } else if entry.file_type().map(|ft| ft.is_dir()).unwrap_or(false) && depth > 0 {
            output.push_str(&format!("{}üìÅ {}\n", indent, path.file_name().unwrap().to_string_lossy()));
        }
    }
    
    output.push_str("```\n\n");
    
    // File contents
    if !cli.tree_only {
        output.push_str("## File Contents\n\n");
        
        for path in &files_to_process {  // <- –¥–æ–±–∞–≤–∏–ª–∏ &
            output.push_str(&format!("<file path=\"{}\">\n", path.display()));
            
            match fs::read_to_string(path) {  // <- —É–±—Ä–∞–ª–∏ & –∑–¥–µ—Å—å, —Ç–∞–∫ –∫–∞–∫ path —É–∂–µ —Å—Å—ã–ª–∫–∞
                Ok(content) => {
                    output.push_str(&content);
                    if !content.ends_with('\n') {
                        output.push('\n');
                    }
                }
                Err(_) => {
                    output.push_str("(binary file or read error)\n");
                }
            }
            
            output.push_str("</file>\n\n");
        }
    }
    
    // Write output
    let mut file = fs::File::create(&cli.output)?;
    file.write_all(output.as_bytes())?;
    
    println!("‚úÖ Context generated: {}", cli.output.display());
    println!("üìä Total size: {} bytes", output.len());
    println!("üìÅ Files processed: {}", files_to_process.len());
    
    Ok(())
}
