use clap::Parser;
use ignore::WalkBuilder;
use std::fs;
use std::io::Write;
use std::path::PathBuf;

#[derive(Parser)]
#[command(name = "repo-context")]
#[command(about = "Generate repository context for AI consumption", long_about = None)]
struct Cli {
    /// Output file path
    #[arg(short, long, default_value = "context.md")]
    output: PathBuf,

    /// Additional patterns to exclude (comma-separated)
    #[arg(short, long)]
    exclude: Option<String>,

    /// Show file tree only (no content)
    #[arg(short, long)]
    tree_only: bool,
}

fn main() -> std::io::Result<()> {
    let cli = Cli::parse();
    
    let mut output = String::new();
    
    // Header
    output.push_str("# Repository Context\n\n");
    output.push_str("Generated by repo-context\n\n");
    
    // File tree
    output.push_str("## File Tree\n\n```\n");
    
    let mut files_to_process = Vec::new();
    
    for result in WalkBuilder::new(".").hidden(false).build() {
        let entry = match result {
            Ok(entry) => entry,
            Err(_) => continue,
        };
        
        let path = entry.path();
        
        // Skip the output file itself
        if path == cli.output.as_path() {
            continue;
        }
        
        // Calculate depth for tree visualization
        let depth = path.components().count() - 1;
        let indent = "  ".repeat(depth);
        
        if entry.file_type().map(|ft| ft.is_file()).unwrap_or(false) {
            output.push_str(&format!("{}ğŸ“„ {}\n", indent, path.display()));
            if !cli.tree_only {
                files_to_process.push(path.to_path_buf());
            }
        } else if entry.file_type().map(|ft| ft.is_dir()).unwrap_or(false) && depth > 0 {
            output.push_str(&format!("{}ğŸ“ {}\n", indent, path.file_name().unwrap().to_string_lossy()));
        }
    }
    
    output.push_str("```\n\n");
    
    // File contents
    if !cli.tree_only {
        output.push_str("## File Contents\n\n");
        
        for path in files_to_process {
            output.push_str(&format!("<file path=\"{}\">\n", path.display()));
            
            match fs::read_to_string(&path) {
                Ok(content) => {
                    output.push_str(&content);
                    if !content.ends_with('\n') {
                        output.push('\n');
                    }
                }
                Err(_) => {
                    output.push_str("(binary file or read error)\n");
                }
            }
            
            output.push_str("</file>\n\n");
        }
    }
    
    // Write output
    let mut file = fs::File::create(&cli.output)?;
    file.write_all(output.as_bytes())?;
    
    println!("âœ… Context generated: {}", cli.output.display());
    println!("ğŸ“Š Total size: {} bytes", output.len());
    
    Ok(())
}
